<!DOCTYPE html>
<html>

<head>
    <title>Augmented Communities Starter</title>
    <style>
        body {
            margin: 0;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #map {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 300px;
            height: 300px;
        }

        .parent {
            width: 100%;
            height: 100%;
        }
        #monitor, #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #videoElement {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="parent">
        <div id="monitor">
            <video autoplay="true" id="videoElement"></video>
        </div>
        <div id="mainCanvas"></div>
        <div id="map"></div>
    </div>

    <script src="js/three.js"></script>
    <script src="js/fulltilt.js"></script>
    <script>

        // Thanks https://en.wikipedia.org/wiki/Geographic_coordinate_system#Expressing_latitude_and_longitude_as_linear_units
        function latitudeDifferenceMeters(referenceLat, measurementLat)
        {
            var metersPerLatDegree = 111132.92 - 559.82 * Math.cos(2 * referenceLat) + 1.175 * Math.cos(4 * referenceLat) - 0.0023 * Math.cos(6 * referenceLat);
            var degreeDifference = measurementLat - referenceLat;
            return degreeDifference * metersPerLatDegree;
        }
        function longitudeDifferenceMeters(referenceLat, longA, longB)
        {
            var metersPerLongDegree = 111412.84 * Math.cos(referenceLat) - 93.5 * Math.cos(3 * referenceLat) + 0.118 * Math.cos(5 * referenceLat);
            var degreeDifference = longB - longA;
            return degreeDifference * metersPerLongDegree;
        }

        // CREATE THREE.JS SCENE
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 0);
        
        // var helper = new THREE.CameraHelper( camera );
        // scene.add( helper );
        // var camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // camera2.position.set(0, 0, 0);

        var renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setClearAlpha(0.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        var canvas = document.getElementById("mainCanvas");
        canvas.appendChild(renderer.domElement);

        class Monument {
            constructor (latitude, longitude, altitude, heading, create, update) {
                this.latitude = latitude;
                this.longitude = longitude;
                this.altitude = altitude;
                this.heading = heading;
                this.create = create.bind(this);
                this.update = update.bind(this);
            }

            initialize(scene) {
                this.monumentGroup = new THREE.Group();
                this.create(this.monumentGroup);
                this.monumentGroup.rotation.set(0, this.heading, 0);
                scene.add(this.monumentGroup);
            }

            updatePositionRelativeToReferenceLatLon(referenceLat, referenceLon) {
                var zPos = latitudeDifferenceMeters(referenceLat, this.latitude);
                var xPos = longitudeDifferenceMeters(referenceLat, referenceLon, this.longitude);
                this.monumentGroup.position.set(xPos, this.altitude, -zPos);
            }
        }

        // CREATE MONUMENT
        var testMonument = new Monument(
             37.730425,
             -122.442796,
             0,
             Math.PI / 2,
             function(group) {
                var geometry = new THREE.BoxGeometry(1, 1, 1);
                var greenMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                var redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var ringRadius = 5;
                var numCubes = 30;

                var cubes = []
                this.angleOffset = 0;
                for (var i = 0; i < numCubes; i++)
                {
                    var cube = new THREE.Mesh(geometry, greenMaterial);
                    if (i == 0)
                    {
                        cube.material = redMaterial;
                    }
                    cubes.push(cube);
                    group.add(cube);
                }

                this.positionCubes = function(angleOffset) {
                    for (var i = 0; i < numCubes; i++) {
                        var angle = (i / numCubes) * 2 * Math.PI + this.angleOffset;
                        var cube = cubes[i];
                        cube.position.set(
                                ringRadius * Math.cos(angle),
                                0,
                                ringRadius * Math.sin(angle));
                    }
                }

                this.positionCubes(this.angleOffset);
             },
             function() {
                this.angleOffset += 0.01;
                // this.positionCubes(this.angleOffset)
             }
        )
        testMonument.initialize(scene);

        // CREATE A COMPASS
        var loader = new THREE.FontLoader();
        var blueMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        loader.load( 'fonts/gentilis_bold.typeface.json', function ( font ) {
            var nGeo = new THREE.TextGeometry( 'N', {
                font: font,
                size: 12,
                height: 1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 1,
                bevelSize: 1,
                bevelSegments: 1
            } );
            var n = new THREE.Mesh(nGeo, blueMaterial);
            n.position.set(0, 0, -50);
            scene.add(n);

            var eGeo = new THREE.TextGeometry( 'E', {
                font: font,
                size: 12,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 1
            } );
            var e = new THREE.Mesh(eGeo, blueMaterial);
            e.rotation.set(0, -Math.PI / 2, 0);
            e.position.set(50, 0, 0);
            scene.add(e);

            var sGeo = new THREE.TextGeometry( 'S', {
                font: font,
                size: 12,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 1
            } );
            var s = new THREE.Mesh(sGeo, blueMaterial);
            s.rotation.set(0, Math.PI, 0);
            s.position.set(0, 0, 50);
            scene.add(s);

            var wGeo = new THREE.TextGeometry( 'W', {
                font: font,
                size: 12,
                height: 0.1,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 1
            } );
            var w = new THREE.Mesh(wGeo, blueMaterial);
            w.rotation.set(0, Math.PI / 2, 0);
            w.position.set(-50, 0, 0);
            scene.add(w);
        } );

        // GET DEVICE ORIENTATION
        var orientationPromise = FULLTILT.getDeviceOrientation({ 'type': 'world' });
        var deviceOrientation;
        orientationPromise
            .then(function(controller) {
                deviceOrientation = controller;
            })
            .catch(function(message) {
                console.error(message);
            });
        var motionPromise = FULLTILT.getDeviceMotion();
        var deviceMotion;
        motionPromise
            .then(function(controller) {
                deviceMotion = controller;
            })
            .catch(function(message) {
                console.error(message);
            });

        // GET DEVICE POSITION
        var deviceLat = 0;
        var deviceLon = 0;
        function geo_success(position) {
            deviceLat = +position.coords.latitude;
            deviceLon = +position.coords.longitude

            var map = document.getElementById("map");
            while (map.firstChild) {
                map.removeChild(map.firstChild);
            }
            var img = new Image();
            var api_key = "AIzaSyCadLo8pPkhDABBMIM6dJjySG3QX9BYClE";
            img.src = "https://maps.googleapis.com/maps/api/staticmap?center=" + deviceLat + "," + deviceLon + "&zoom=19&size=300x300&sensor=false&markers=size:tiny%7Ccolor:red%7C"+deviceLat+","+deviceLon+"&markers=size:tiny%7Ccolor:blue%7C"+testMonument.latitude+","+testMonument.longitude+"&key=" + api_key;
            map.appendChild(img);
        }
        function geo_error() {
            console.log("Sorry, no position available.");
            // GPS not available, so hardcode the coords of the Grand Theater!
            deviceLat = 37.7545505;
            deviceLon = -122.4184645;
        }
        var geo_options = {
            enableHighAccuracy: true,
            maximumAge        : 30000,
            timeout           : 27000
        };
        var wpid = navigator.geolocation.watchPosition(geo_success, geo_error, geo_options);

        // GET CAMERA STREAM
        var video = document.querySelector("#videoElement");
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            console.log("enumerateDevices() not supported.");
            video.remove();
        }
        else
        {
            var constraints = {
                video: {
                    facingMode: "environment"
                }
            };
            navigator.mediaDevices.getUserMedia(constraints)
                .then(function(stream) {
                    handleVideo(stream);
                }).catch(function(err) {
                    videoError(err);
                });
        }
        function handleVideo(stream) {
            video.src = window.URL.createObjectURL(stream);
        }
        function videoError(e) {
            // do something
        }

        var camAngle = 0;
        var camAngleIncrement = Math.PI / 200;
        // RUN RENDER LOOP
        // Computed device orientation rotation vector
        var orientationQuat = new THREE.Quaternion();
        // World frame transform (- PI/2 around the x-axis)
        var worldQuat = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) );
        var render = function () {
            requestAnimationFrame(render);

            // If we have a valid FULLTILT.DeviceOrientation object then use it
            if (deviceMotion && deviceOrientation) {
                var rotRate = deviceMotion.getScreenAdjustedRotationRate();
                if (rotRate.alpha !== null) // Check if there's a gyro in the device
                {
                    var quat = deviceOrientation.getScreenAdjustedQuaternion();
                    orientationQuat.set( quat.x, quat.y, quat.z, quat.w );
                    // IMPORTANT! set deviceorientation camera to three.js world frame
                    // (i.e. make camera look out the back of the screen by rotating the camera x-axis by -PI/2)
                    camera.quaternion.multiplyQuaternions( worldQuat, orientationQuat );
                }
            }

            testMonument.update();
            testMonument.updatePositionRelativeToReferenceLatLon(deviceLat, deviceLon);

            // var camRadius = 20;
            // camAngle += camAngleIncrement;
            // camera2.position.set(camRadius * Math.cos(camAngle), 10, camRadius * Math.sin(camAngle));
            // camera2.lookAt(new THREE.Vector3(0, 0, 0));

            renderer.render(scene, camera);
        };

        render();
    </script>
</body>

</html>